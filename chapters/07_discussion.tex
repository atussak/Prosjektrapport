\chapter{Discussion} \label{ch:discussion}

This chapter looks at the effects of simplifications and approximations made during the development of the simulator both in regard of the dynamical model and in regard of the path following method. These effects, as well as the general results from the experiments are discussed and some improvements are proposed.

\section{Effects of the contact behaviour simplification}

The geometrical approximation made regarding the contact forces between the robot and the obstacles have been characteristic for the outcome of the simulations. Firstly, it might not yield unique solutions, leading to unpredictable or unrealistic behavior in some scenarios. Secondly, it has been observed that the robot in some cases ends up moving slightly over the edge of obstacles when there are several "conflicting" constraints present.

From a physical perspective, it is obvious that projecting the velocities to an "allowable space" just based on the positioning of the obstacles differs from the resulting velocities after a collision. Projecting the velocities means that the velocity of the robot body might be increased after contact with an obstacle. This does in turn mean increasing the total energy of the system, which contradicts basic laws of physics.  

There are of course several methods that could have avoided this simplification.
One option would be to implicitly define the forces as a part of the dynamical model, in the same way as the forces between the joints in the robot are implicitly defined. The method of Yoshikawa \cite{yoshikawa1987dynamic}, explained in \ref{subseq:dynhpfc}, follows this approach. It does however only consider constraints on the end effector of the robot, and not on arbitrary links. The adjustment that has to be made in the snake robot case, is that the constraint hypersurfaces and forces onto these surfaces have to be defined for every contact point.

%\hl{Could we have used Paf to find the component belonging to the constraint++ space???}

Another consequence of the geometrical approximation, is that the projection matrices only allow movement along obstacles. This is necessary for preventing the robot in moving through obstacles, but also prevents the robot from perpendicularly moving away from them. In other words, whenever a link comes in contact with an obstacle, it will stick to it until it has slid along it. This strict positioning of the links can come in conflict with the controller and path projection. The only case in which a link "detaches" from the obstacle before sliding all the way along it, is when it in a discrete time step is projected to a position where it no longer is considered in contact and fazed by the obstacle.

Yet another important remark, is that the program treats the cases in which a link is on the edge of the obstacle radius and within the obstacle radius equally. In particular, it considers both cases a point contact and disregards how close it is to the actual obstacle point. In \ref{subseq:case23} it is pointed out that the robot slides slightly through this radius, but keep in mind that for the robot it is the same as sliding on the edge. However, it is of course a mistake that the robot ended up within the radius in the first place, but it is most probably a result of the discrete nature of the simulator. Furthermore, it is the velocity rather than position of the robot that is changed with the projection. The robot might thus still be inside the obstacle radius at the next time step. Decreasing the radius would naturally also decrease this effect, but it is still crucial to keep in the discrete simulations.

A workaround for the rigid definition of contact, in which the robot is either completely in contact with the obstacle or not at all, could be introducing an elastic radius or force field around the obstacles, and thus damp the nonlinear effects of the interactions. %PD controller


\section{Review of the path alignment method}

The method of finding the desired angles based on projection onto the path is not robust in cases where the links are far from the path (see experiment in \ref{subseq:case12}). The simplest solution would be avoiding the projection of links that are very misplaced. A future, more advanced, solution would be redefining the optimal path to overlap with the current position of the robot. In \ref{subseq:case12} it is pointed out that the method of finding the desired joint angles disregards the positions of the two first joints, or rather the position of the start- and end point of the tail-link. Correcting this poor quality would improve the performance of the path following capability significantly. Situations like in \ref{subseq:case24} where the tail of the robot gets stuck would then be avoided.

The desired joint angles from the path projection method are calculated separately for each link in the current program. A more robust and intelligent solution would be defining an objective function that considers the deviation from the path for all joints, and then finds the set of joint desired angles minimizing the complete set of deviations. By this method it would also be possible to weight the error of the snake robot head the most. Holden \cite{holden2014optimal} has formulated an optimization problem that finds input torques by minimizing energy consumption while achieving propulsion along the desired path. The method is a great inspiration, but not quite yet a solution to the problem as it still requires the desired joint angles at the obstacles.

\section{Further insights from experiments}

On the more constructive side, it is clear that the simulator has proven to be a great resource for presenting concepts and study the possibilities within obstacle aided locomotion. Furthermore, the modular architecture of the program, where controller, dynamics, path following etc. is decoupled, allows for it to be effortlessly modified.

The experiments have shown that the positioning of the obstacles and path in relation to each other is vital for the propulsion of the robot. This is especially the case in an environment where the possibility to aid friction for propulsion is absent. Furthermore, it has been shown that it is necessary to have a sufficient number of obstacles. Not only for the propulsion, but also for continuously aiding the robot with alignment along the path. Consequently, a limitation of the implemented system is that the configuration of obstacles and desired path need to be determined manually.

A further observation from the experiments, in particular \ref{subseq:case23}, is that the obstacles used for aligning the rear part of the robot are comparable to a manipulator base. More specifically, the robot is in this position able to keep its rear links fixed in the perpendicular direction and thus control the proceeding links to go in this direction
This does in turn lead to the robot being able to get further with a greater number of links, as the robot slides through the aligning obstacles for a longer period of time.

When it comes to the computational performance of the simulator, it is observed that the program requires significantly more time for computing the initialization of robots with 6 links or more than that of robots with fewer links. An improvement would have been defining the equations of motion directly rather than performing symbolic math differentiation to derive them. However, the initialization only has to run once for every configuration, and the real time visual performance of the actual simulation is still satisfactory for sample times greater than 0.001 seconds.



